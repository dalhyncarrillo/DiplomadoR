[
["index.html", "Diplomado en R Capítulo 1 Prerequisitos 1.1 Instalación de R 1.2 Entornos de desarrollo para R", " Diplomado en R Francisco Javier Luna Vázquez 2017-04-22 Capítulo 1 Prerequisitos 1.1 Instalación de R Empezaremos por lo más básico, Podemos instalar R desde el siguiente link: https://www.r-project.org/ Pero como muchos somos algo despistados, estas son las maneras más sencillas para instalar R en distintos Sistemas Operativos: Sistema Operativo Método Windows CRAN-R-Windows.Exe Debian y derivados sudo apt-get install r-base Redhat y derivados sudo yum install R-core R-devel Arch y derivados sudo pacman -S r Mac https://www.youtube.com/watch?v=ICGkG7Gg6j0 1.2 Entornos de desarrollo para R Una vez instalado, un entorno de desarrollo integrado será necesario para facilitar el desarrollo de códigos en R, por lo que se presentan tres de varias opciones para trabajar con R. IDE Link Tinn-R https://sourceforge.net/projects/tinn-r/ RStudio [Recomendado] https://www.rstudio.com/ R commander (Rcmdr) http://www.rcommander.com/ RIDE En este caso, Sera necesario instalar RStudio para realizar los ejercicios de manera cómoda, por lo que, para instalar RStudio para los distintos Sistemas Operativos podemos hacerlo desde la liga principal, o para evitar buscar podemos usar la liga que más nos convenga de la siguiente tabla. Rstudio enlace Windows https://download1.rstudio.org/RStudio-1.0.136.exe Linux (Debian y derivados) https://download1.rstudio.org/rstudio-1.0.136-amd64.deb Linux (RedHat y derivados) https://download1.rstudio.org/rstudio-1.0.136-x86_64.rpm Linux (Arch y derivados) sudo pacman -S rstudio-desktop Mac https://download1.rstudio.org/RStudio-1.0.136.dmg Y finalmente sera necesario tener instalados el siguiente paquete: install.packages(&quot;dplyr&quot;) install.packages(&quot;rmarkdown&quot;, dependencies = TRUE) Dichos paquetes nos servirán para la manipulación de datos (dplyr) y crear documentos dinámicos en la tercera parte del curso. "],
["introduccion-a-r.html", "Capítulo 2 Introducción a R 2.1 Primeros pasos 2.2 Clases de datos 2.3 Manejo de datos 2.4 Tratamiento de datos", " Capítulo 2 Introducción a R 2.1 Primeros pasos Para interactuar con R se dispone de una potente línea de comandos y en un principio, la manera más sencilla de ver R es que puede ser usado como una calculadora: Como sumar: 10+5 ## [1] 15 O dividir: 10/5 ## [1] 2 Sin embargo, su potencial va más allá… Principalmente porque este documento ha sido diseñado en R y RMarkdown ;) 2.1.1 Establecer directorios de trabajo Al ejecutar R, este establece un directorio de trabajo, es decir, establece una carpeta donde guardar los datos ejecutados en R, misma que será la carpeta que usara para buscar, leer y escribir los archivos (de ser requerido) durante la sesión (es decir, mientras se mantiene el programa abierto), por ello, para obtener el directorio de trabajo actual basta con usar el siguiente comando: getwd() ## [1] &quot;/home/frahik/Documentos/R-project/DiplomadoR&quot; Dicho directorio va a variar dependiendo del sistema, por ello, más de una vez será necesario modificar esta ruta, para lo cual se usara el comando setwd(&quot;Ruta&quot;), el cual varía dependiendo del Sistema Operativo, como buena práctica del programador, se recomienda establecer el directorio de trabajado dentro de la carpeta de Documentos, además de que es más sencillo encontrar los proyectos de trabajo, si se usa la ruta ruta relativa y no la ruta física, si se requiere mover todos los archivos para trabajar en otra computadora, no se tendrá que volver a modificar todo el directorio de trabajo. Ejemplo usando la Ruta relativa en Linux setwd(&quot;~/Documentos/Curso&quot;) #Linux Ejemplo usando la Ruta física y la ruta relativa en Windows setwd(&quot;C:\\\\Usuario\\\\Documentos\\\\Curso&quot;) #MALA PRACTICA (Ruta física) setwd(&quot;~/Curso&quot;) #BUENA PRACTICA (Ruta relativa del comando anterior) 2.1.2 Creación de objetos/variables En R podemos crear y manipular objetos asignándole valores, cadenas de texto, funciones y un largo etc. Por ser el primer contacto con R, crearemos un objeto (izquierda del símbolo =), asignándole como valor la cadena de texto “Hola mundo”. Es importante aclarar que es necesario que se pongan dobles comillas &quot; &quot; o comillas simples ' ' al escribir una cadena de texto, de otra manera será interpretado como uno o varios objetos, ejemplo: saludo = Hola ## Error in eval(expr, envir, enclos): objeto &#39;Hola&#39; no encontrado Por lo que, para insertar la cadena de texto “Hola mundo” en la variable saludo, se deberá hacer como se mencionó anteriormente: saludo = &quot;Hola mundo&quot; Ahora para mostrar en consola lo que contiene la variable u objeto saludo, lo escribiremos tal cual y obtendremos una salida muy similar a la siguiente. ## [1] &quot;Hola mundo&quot; NOTAS IMPORTANTES: R es sensible a las MAYÚSCULAS y minúsculas, por lo que saludo no es igual a Saludo, ni a SALUDO. R NO requiere explicitar que tipo de valores van a contener las variables, Otra manera de asignar valores a las variables es mediante el símbolo &lt;- que se compone de un menor que y el signo de menos. x &lt;- 10 + 5 «Podemos ver a las variables como una persona, cada persona tiene su nombre para poder ser identificadas sobre el resto de las personas, pero bajo la manera de ordenar del lenguaje R, si dos personas quieren llamarse de la misma manera, la nueva persona tiene que ‘matar’ a la persona ya existente para poder tomar su lugar.» Se recomienda incluir un espacio simple a cada lado del operador de asignación para incrementar la legibilidad. Pero NO coloques un espacio entre el &lt; y el - que forman la flecha, recuerda que a pesar de estar compuesto por dos caracteres es un único símbolo. Es posible reasignar un valor a la variable que hemos creado, así como reutilizar el valor de la variable para realizar un cálculo: y &lt;- x + 5 y Ahora reutilizaremos el valor de la variable y: ## [1] 20 Recuerde que aunque pareciera algo matemático, los símbolos &lt;- y = no funcionan como un «igual», si no, como un «equivale a» o una «asignación», porque a partir de ese momento, el valor de la derecha se le asigna al de la izquierda. 2.1.3 Instalar librerías Los paquetes en R, son como «Extensiones» y nos sirven para evitar reinventar la rueda, existen muchos paquetes disponibles en el CRAN de R o GitHub y para instalarlos basta un comando en la propia terminal de R: Para paquetes oficiales de CRAN install.packages(&quot;NombreDelPaquete&quot;) library(NombreDelPaquete) #Para usar el paquete Para paquetes de GitHub install.packages(&quot;devtools&quot;) #Correr solo si no se tiene el paquete &quot;devtools&quot; instalado. devtools::install_github(&quot;usuario/repositorio&quot;) Al agregar nuevos paquetes podremos expandir el potencial de R y a la vez facilitarnos el trabajo de «hacerlo por nosotros mismos». 2.1.4 Ayuda y documentación R Nos proporciona toda la documentación de sus paquetes, así que si se nos olvida para que funciona un comando o por que la función no hace lo que uno escribe, revisar la documentación podrá evitar que pases horas frente al ordenador buscando el «punto y coma» que te falta, cuando en R los códigos no lo llevan. help(nombre) Donde nombre puede ser cualquier función o librería instalada de R. Ejemplos: help(help) #Sí, es posible help(sum) #Documentación de una función help(slidify) #Documentación de un paquete 2.2 Clases de datos Existen 4 tipos de clases de objetos con las que tendremos que trabajar en R, cada uno tiene sus ventajas y desventajas, así que se verá de manera detalla cómo crear cada uno de ellos, acceder a sus valores, así como posibles problemas. 2.2.1 Vector Desde que empezamos con la variable saludo, estábamos trabajando con vectores, sin embargo, era un vector de índice 1, dado que en R no existen como en otros lenguajes las variables individuales, todas a las que se les asigna un valor o más, son tratados inicialmente como vectores. La manera de representar un vector es de la siguiente forma: Valor1 Valor2 Valor3 … Valorn Una forma de ver a los vectores, es como la fila de espera del banco, todos tienen un turno único, pero que puede ser transferible, por lo que si mando a llamar el primer turno, solo el cliente con ese turno será el que pasará a ventanilla, pero mientras, el cliente con turno 10, puede ser que esté guardando el lugar para un amigo y cuando el amigo llegue, el nuevo cliente sustituirá al actual cliente con el turno 10. Una vez entendido el mensaje anterior, existen varias formas de declarar un vector de más de un valor, la manera más sencilla es a través de la función concatenar c(...); la cual es una función genérica que combina los valores separado por comas en un vector. Ejemplos: Vector con varios datos y un NA: vector &lt;- c(1:9,NA,10:15) vector ## [1] 1 2 3 4 5 6 7 8 9 NA 10 11 12 13 14 15 Vector de nombres de personas: vectorNombres &lt;- c(&quot;Francisco&quot;,&quot;Claudia&quot;,&quot;Valeria&quot;,&quot;Fernando&quot;,&quot;Julia&quot;) vectorNombres ## [1] &quot;Francisco&quot; &quot;Claudia&quot; &quot;Valeria&quot; &quot;Fernando&quot; &quot;Julia&quot; Vector con los datos de otros vectores: vec1 &lt;- 1 vec2 &lt;- 20:30 vecFinal &lt;- c(vec1,vec2) vecFinal ## [1] 1 20 21 22 23 24 25 26 27 28 29 30 Ya que hemos visto como se crea un vector ahora veremos cómo acceder y trabajar con los valores de un vector. 2.2.1.1 Acceder a uno o varios datos del vector. Tenemos el siguiente vector que tiene almacenado el nombre de 6 clientes. vector &lt;- c(&quot;Francisco&quot;,&quot;Claudia&quot;,&quot;Valeria&quot;,&quot;Fernando&quot;,&quot;Julia&quot;, &quot;Osval&quot;) Francisco Claudia Valeria Fernando Julia Osval En R a diferencia de otros lenguajes de programación como C o Java, los índices de un vector o una matriz siempre inician en 1 y no en 0 como en esos otros lenguajes, por lo que la tabla anterior se podría observar de la siguiente manera: 1 2 3 4 5 6 Francisco Claudia Valeria Fernando Julia Osval Donde el primer índice, hace referencia al primer elemento del vector, el segundo índice al segundo elemento y así de manera consecutiva. Por lo que para acceder a uno o varios elementos se pueden utilizar los siguientes códigos: Un elemento en específico vector[3] ## [1] &quot;Valeria&quot; Varios elementos en secuencia. vector[2:4] ## [1] &quot;Claudia&quot; &quot;Valeria&quot; &quot;Fernando&quot; Un elemento especificado anteriormente. n &lt;- 3 vector[n] ## [1] &quot;Valeria&quot; Varios elementos especificados vector[c(1,2,5)] ## [1] &quot;Francisco&quot; &quot;Claudia&quot; &quot;Julia&quot; Todos los elementos, excluyendo uno específico. vector[-3] ## [1] &quot;Francisco&quot; &quot;Claudia&quot; &quot;Fernando&quot; &quot;Julia&quot; &quot;Osval&quot; Todos los elementos, excluyendo varios. vector[-c(4:6)] ## [1] &quot;Francisco&quot; &quot;Claudia&quot; &quot;Valeria&quot; Almacenar los datos extraídos en otra variable. grupo1 &lt;- vector[-c(4:6)] grupo1 ## [1] &quot;Francisco&quot; &quot;Claudia&quot; &quot;Valeria&quot; Modificar un elemento específico de un vector vector[4] &lt;- &quot;Alberto&quot; vector ## [1] &quot;Francisco&quot; &quot;Claudia&quot; &quot;Valeria&quot; &quot;Alberto&quot; &quot;Julia&quot; &quot;Osval&quot; Modificar varios elementos de un vector vector[4:6] &lt;- NA vector ## [1] &quot;Francisco&quot; &quot;Claudia&quot; &quot;Valeria&quot; NA NA NA Encontrar las posiciones de los valores NA (Not Available) en un vector is.na(vector) ## [1] FALSE FALSE FALSE TRUE TRUE TRUE Encontrar las posiciones de los valores que no sean NA en un vector !is.na(vector) ## [1] TRUE TRUE TRUE FALSE FALSE FALSE Extraer los elementos de las posiciones en los que los valores NO son NA which(!is.na(vector) == TRUE) ## [1] 1 2 3 # Alternativa which(is.na(vector) == FALSE) ## [1] 1 2 3 Extraer las posiciones del vector que cumplan con una consulta which(vector == &quot;Francisco&quot;) ## [1] 1 Modificar las posiciones del vector que cumplan con una consulta vector[which(vector == &quot;Francisco&quot;)] &lt;- &quot;Francisco Javier&quot; 2.2.1.2 Ordenar los datos de un vector Para ordenar los datos existe la función sort(...). Ordenar un vector de forma creciente sort(vector) ## [1] &quot;Claudia&quot; &quot;Francisco Javier&quot; &quot;Valeria&quot; Ordenar un vector de forma decreciente sort(vector, decreasing = T) ## [1] &quot;Valeria&quot; &quot;Francisco Javier&quot; &quot;Claudia&quot; Ordenar un vector y conocer sus antiguas posiciones. sort(vector, decreasing = T, index.return = TRUE) ## $x ## [1] &quot;Valeria&quot; &quot;Francisco Javier&quot; &quot;Claudia&quot; ## ## $ix ## [1] 3 1 2 Este último método retorna dos listas, la primera es $x que representa la lista de los valores ordenados y la segunda es $ix que representa las antiguas posiciones de los valores. 2.2.1.3 Tratar los datos de un vector Tenemos un vector con los gastos de la última semana: gastos &lt;- c(150,120,300,250,400,380,100) Que se pueden representar de la siguiente manera: 150 120 300 250 400 380 100 En R ya existen varias funciones para ser utilizadas, se mostrará el funcionamiento de algunas de ellas y otras más podrán ser encontradas en el Capítulo 5 (Apéndices). El menor gasto en la semana min(gastos) ## [1] 100 El mayor gasto en la semana max(gastos) ## [1] 400 Obtener el promedio de gasto en la semana. mean(gastos) ## [1] 242.8571 Obtener el total del gasto de la semana, (Sumar todos los elementos). sum(gastos) ## [1] 1700 Obtener el total del gasto de una semana laboral (Lunes-Viernes), (Sumar elementos específicos) sum(gastos[1:5]) ## [1] 1220 Obtener la varianza del gasto semanal var(gastos) ## [1] 15157.14 Obtener la desviación estándar del gasto semanal sd(gastos) ## [1] 123.1143 Obtener un resumen de los datos summary(gastos) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 100.0 135.0 250.0 242.9 340.0 400.0 Este último comando muestra mucha información de utilidad, el valor mínimo, el primer cuantil, la mediana, el promedio, el tercer cuantil y el valor máximo dentro del vector. Con el cuál, se puede ahorrar tiempo a que si se utiliza de manera separada como se ve en los primeros tres comandos. 2.2.1.4 Problemas comunes 2.2.1.4.1 Mayúsculas y minúsculas Como ya se mencionó anteriormente, R es sensible a las Mayúsculas y Minúsculas, por lo que las funciones no funcionaran si se ponen total o parcialmente en Mayúsculas, para comprender esto veremos dos ejemplos: Crear un vector: MAL [X] vector &lt;- C(1,2,3) ## Error in C(1, 2, 3): object not interpretable as a factor BIEN [O] vector &lt;- c(1,2,3) Sumar los datos de un vector: MAL [X] vector &lt;- c(1,2,3) SUM(vector) ## Error in eval(expr, envir, enclos): no se pudo encontrar la función &quot;SUM&quot; BIEN [O] vector &lt;- c(1,2,3) sum(vector) ## [1] 6 2.2.2 Matriz Para crear una matriz en R se utiliza la función matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL) Donde matrix() corresponde al nombre de la función y todo lo que está dentro de los paréntesis son los argumentos de dicha función. Argumentos Significado del argumento data Son los datos a ingresar en la matriz. nrow Número deseado de filas. ncol Número deseado de columnas. byrow Valor lógico. Si es falso (valor por defecto), la matriz se llena por orden columna, de otra manera se llenará primero por filas. dimnames Utilizado para darles nombres a las filas y a las columnas, respectivamente. 2.2.2.1 Crear una matriz Algunos ejemplos de cómo crear una matriz: Una matriz de NA de 5 * 5: m &lt;- matrix(NA, nrow = 5, ncol = 5) Una matriz desde los datos de un vector: vector &lt;- c(&quot;Francisco&quot;, 500, &quot;Alberto&quot;, 200, &quot;Enrique&quot;, 650, &quot;Juan&quot;, 300) m &lt;- matrix(vector, ncol = 2, byrow = T) m Una matriz desde los datos de dos o más vectores: Nombre &lt;- c(&quot;Francisco&quot;, &quot;Alberto&quot;, &quot;Enrique&quot;, &quot;Juan&quot;) Puntos &lt;- c(500, 200, 650, 300) m &lt;- matrix(c(Nombre, Puntos), ncol = 2) m ## [,1] [,2] ## [1,] &quot;Francisco&quot; &quot;500&quot; ## [2,] &quot;Alberto&quot; &quot;200&quot; ## [3,] &quot;Enrique&quot; &quot;650&quot; ## [4,] &quot;Juan&quot; &quot;300&quot; Una matriz desde los datos de dos o más vectores con cbind: Nombre &lt;- c(&quot;Francisco&quot;, &quot;Alberto&quot;, &quot;Enrique&quot;, &quot;Juan&quot;) Puntos &lt;- c(500, 200, 650, 300) m &lt;- cbind(Nombre, Puntos) m ## Nombre Puntos ## [1,] &quot;Francisco&quot; &quot;500&quot; ## [2,] &quot;Alberto&quot; &quot;200&quot; ## [3,] &quot;Enrique&quot; &quot;650&quot; ## [4,] &quot;Juan&quot; &quot;300&quot; Una matriz desde los datos de dos o más vectores con rbind: Cliente1 &lt;- c(&quot;Francisco&quot;, 500) Cliente2 &lt;- c(&quot;Alberto&quot;, 200) Cliente3 &lt;- c(&quot;Enrique&quot;, 650) m &lt;- rbind(Cliente1, Cliente2, Cliente3) m ## [,1] [,2] ## Cliente1 &quot;Francisco&quot; &quot;500&quot; ## Cliente2 &quot;Alberto&quot; &quot;200&quot; ## Cliente3 &quot;Enrique&quot; &quot;650&quot; 2.2.2.2 Trabajar con matrices Continuaremos trabajando con la siguiente matriz, es necesario recordar que se puede llamar de cualquier forma, en este caso se llamará de manera genérica, matriz : Nombre &lt;- c(&quot;Francisco&quot;, &quot;Alberto&quot;, &quot;Enrique&quot;, &quot;Juan&quot;, &quot;Francisco&quot;, &quot;Alberto&quot;, &quot;Enrique&quot;, &quot;Juan&quot;) Puntos &lt;- c(500, 200, 650, 300, 300, 350, 600, 400) matriz &lt;- cbind(Nombre, Puntos) matriz ## Nombre Puntos ## [1,] &quot;Francisco&quot; &quot;500&quot; ## [2,] &quot;Alberto&quot; &quot;200&quot; ## [3,] &quot;Enrique&quot; &quot;650&quot; ## [4,] &quot;Juan&quot; &quot;300&quot; ## [5,] &quot;Francisco&quot; &quot;300&quot; ## [6,] &quot;Alberto&quot; &quot;350&quot; ## [7,] &quot;Enrique&quot; &quot;600&quot; ## [8,] &quot;Juan&quot; &quot;400&quot; Nombrar las columnas de la matriz colnames(matriz) &lt;- c(&quot;Cliente&quot;, &quot;Puntos&quot;) matriz ## Cliente Puntos ## [1,] &quot;Francisco&quot; &quot;500&quot; ## [2,] &quot;Alberto&quot; &quot;200&quot; ## [3,] &quot;Enrique&quot; &quot;650&quot; ## [4,] &quot;Juan&quot; &quot;300&quot; ## [5,] &quot;Francisco&quot; &quot;300&quot; ## [6,] &quot;Alberto&quot; &quot;350&quot; ## [7,] &quot;Enrique&quot; &quot;600&quot; ## [8,] &quot;Juan&quot; &quot;400&quot; Nombrar las filas de la matriz rownames(matriz) &lt;- c(&quot;Compra1&quot;, &quot;Compra2&quot;, &quot;Compra3&quot;, &quot;Compra4&quot;, &quot;Compra5&quot;, &quot;Compra6&quot;, &quot;Compra7&quot;, &quot;Compra8&quot;) matriz ## Cliente Puntos ## Compra1 &quot;Francisco&quot; &quot;500&quot; ## Compra2 &quot;Alberto&quot; &quot;200&quot; ## Compra3 &quot;Enrique&quot; &quot;650&quot; ## Compra4 &quot;Juan&quot; &quot;300&quot; ## Compra5 &quot;Francisco&quot; &quot;300&quot; ## Compra6 &quot;Alberto&quot; &quot;350&quot; ## Compra7 &quot;Enrique&quot; &quot;600&quot; ## Compra8 &quot;Juan&quot; &quot;400&quot; Nombrar las columnas y las filas de la matriz dimnames(matriz) &lt;- list(c(&quot;C1&quot;, &quot;C2&quot;, &quot;C3&quot;, &quot;C4&quot;, &quot;C5&quot;, &quot;C6&quot;, &quot;C7&quot;, &quot;C8&quot;),c(&quot;Cliente&quot;, &quot;Puntos&quot;)) matriz ## Cliente Puntos ## C1 &quot;Francisco&quot; &quot;500&quot; ## C2 &quot;Alberto&quot; &quot;200&quot; ## C3 &quot;Enrique&quot; &quot;650&quot; ## C4 &quot;Juan&quot; &quot;300&quot; ## C5 &quot;Francisco&quot; &quot;300&quot; ## C6 &quot;Alberto&quot; &quot;350&quot; ## C7 &quot;Enrique&quot; &quot;600&quot; ## C8 &quot;Juan&quot; &quot;400&quot; Obtener los primeros valores de una matriz (tres en este caso): head(matriz,3) ## Cliente Puntos ## C1 &quot;Francisco&quot; &quot;500&quot; ## C2 &quot;Alberto&quot; &quot;200&quot; ## C3 &quot;Enrique&quot; &quot;650&quot; Obtener los últimos valores de una matriz (tres en este caso): tail(matriz,3) ## Cliente Puntos ## C6 &quot;Alberto&quot; &quot;350&quot; ## C7 &quot;Enrique&quot; &quot;600&quot; ## C8 &quot;Juan&quot; &quot;400&quot; Obtener los nombres de los clientes: matriz[,1] ## C1 C2 C3 C4 C5 C6 ## &quot;Francisco&quot; &quot;Alberto&quot; &quot;Enrique&quot; &quot;Juan&quot; &quot;Francisco&quot; &quot;Alberto&quot; ## C7 C8 ## &quot;Enrique&quot; &quot;Juan&quot; Obtener los nombres ordenados: sort(matriz[,1]) ## C2 C6 C3 C7 C1 C5 ## &quot;Alberto&quot; &quot;Alberto&quot; &quot;Enrique&quot; &quot;Enrique&quot; &quot;Francisco&quot; &quot;Francisco&quot; ## C4 C8 ## &quot;Juan&quot; &quot;Juan&quot; Obtener los nombres de los clientes sin repetir: unique(matriz[,1]) ## [1] &quot;Francisco&quot; &quot;Alberto&quot; &quot;Enrique&quot; &quot;Juan&quot; Obtener los nombres de los clientes sin repetir y ordenados: sort(unique(matriz[,1])) ## [1] &quot;Alberto&quot; &quot;Enrique&quot; &quot;Francisco&quot; &quot;Juan&quot; Obtener la matriz ordenada según la cantidad de Puntos (ascendente): matriz[order(matriz[, 2]), ] ## Cliente Puntos ## C2 &quot;Alberto&quot; &quot;200&quot; ## C4 &quot;Juan&quot; &quot;300&quot; ## C5 &quot;Francisco&quot; &quot;300&quot; ## C6 &quot;Alberto&quot; &quot;350&quot; ## C8 &quot;Juan&quot; &quot;400&quot; ## C1 &quot;Francisco&quot; &quot;500&quot; ## C7 &quot;Enrique&quot; &quot;600&quot; ## C3 &quot;Enrique&quot; &quot;650&quot; Obtener la matriz ordenada según la cantidad de Puntos (descendente): matriz[order(matriz[, 2], decreasing = TRUE), ] ## Cliente Puntos ## C3 &quot;Enrique&quot; &quot;650&quot; ## C7 &quot;Enrique&quot; &quot;600&quot; ## C1 &quot;Francisco&quot; &quot;500&quot; ## C8 &quot;Juan&quot; &quot;400&quot; ## C6 &quot;Alberto&quot; &quot;350&quot; ## C4 &quot;Juan&quot; &quot;300&quot; ## C5 &quot;Francisco&quot; &quot;300&quot; ## C2 &quot;Alberto&quot; &quot;200&quot; Note que la matriz NO queda ordena debido a que los datos están saliendo a consola, si buscamos que se queden ordenados, tendríamos que asignarlos a la variable misma o en su defecto a una nueva variable, por ejemplo, matriz &lt;- matriz[order(matriz[, 2], decreasing = TRUE), ]. Obtener al primer cliente y sus puntos: matriz[1,] ## Cliente Puntos ## &quot;Francisco&quot; &quot;500&quot; Obtener la suma de los puntos (ver problemas comunes): sum(as.numeric(matriz[,2])) ## [1] 3300 2.2.2.3 Problemas comunes Estos son algunos de los problemas más comunes al momento de intentar trabajar con una matriz: 2.2.2.3.1 No puedo hacer la suma de números. Es ocasiones R tiende a asignar nuestros datos de otra forma que no es la que nosotros esperamos, en este caso tenemos el siguiente error: sum(matriz[,2]) ## Error in sum(matriz[, 2]): &#39;type&#39; (character) de argumento no válido El error que retorna R es que el tipo ‘character’ no es un argumento válido, esto significa que los datos que nosotros ingresamos son del tipo carácter, para comprobar esto, usaremos la función typeof(…): typeof(matriz[,2]) ## [1] &quot;character&quot; Se puede observar que efectivamente, los datos que intentamos ingresar R los tiene almacenados como tipo carácter, por lo que, para poder sumar los datos utilizaremos la función as.numeric (existen otras funciones como as.integer, as.double() que también podrían funcionar): typeof(as.numeric(matriz[,2])) ## [1] &quot;double&quot; sum(as.numeric(matriz[,2])) ## [1] 3300 2.2.2.3.2 Los nombres en dimnames(...) no concuerdan con las dimensiones de la matriz. Al intentar nombrar una matriz, puede surgir este tipo de errores al usar la función dimnames(...): dimnames(matriz) &lt;- list(c(&quot;Cliente&quot;, &quot;Puntos&quot;), c(&quot;C1&quot;, &quot;C2&quot;, &quot;C3&quot;, &quot;C4&quot;, &quot;C5&quot;, &quot;C6&quot;, &quot;C7&quot;, &quot;C8&quot;)) ## Error in dimnames(matriz) &lt;- list(c(&quot;Cliente&quot;, &quot;Puntos&quot;), c(&quot;C1&quot;, &quot;C2&quot;, : la longitud de &#39;dimnames&#39; [1] no es igual a la extensión del arreglo El error en está ocasión se debe a que estamos intentar poner los nombres de las columnas en las filas y viceversa, así que cambiando el orden de los vectores de nombres es suficiente para que funcione: dimnames(matriz) &lt;- list(c(&quot;C1&quot;, &quot;C2&quot;, &quot;C3&quot;, &quot;C4&quot;, &quot;C5&quot;, &quot;C6&quot;, &quot;C7&quot;, &quot;C8&quot;), c(&quot;Cliente&quot;, &quot;Puntos&quot;)) matriz ## Cliente Puntos ## C1 &quot;Francisco&quot; &quot;500&quot; ## C2 &quot;Alberto&quot; &quot;200&quot; ## C3 &quot;Enrique&quot; &quot;650&quot; ## C4 &quot;Juan&quot; &quot;300&quot; ## C5 &quot;Francisco&quot; &quot;300&quot; ## C6 &quot;Alberto&quot; &quot;350&quot; ## C7 &quot;Enrique&quot; &quot;600&quot; ## C8 &quot;Juan&quot; &quot;400&quot; Pero ¿Qué pasa si no se busca nombrar las filas o las columnas?, lo recomendable sería usar las funciones respectivas colnames(...) o rownames(...). 2.2.2.3.3 Los datos no concuerdan con las dimensiones de la matriz Tenemos los siguientes vectores: Cliente &lt;- c(&quot;Francisco&quot;, &quot;Alberto&quot;, &quot;Juan&quot;) Puntos &lt;- c(10,2030) Observe que el vector Puntos a pesar de que le faltó una coma para separar el valor 20 de 30, R lo sigue tomando como válido por que no rompe con la sintaxis del código, sin embargo, esto nos causará problemas más adelante. Ahora intentaremos crear una matriz con esos datos: matriz &lt;- matrix(c(Cliente, Puntos), ncol=2) ## Warning in matrix(c(Cliente, Puntos), ncol = 2): la longitud de los datos ## [5] no es un submúltiplo o múltiplo del número de filas [3] en la matriz matriz ## [,1] [,2] ## [1,] &quot;Francisco&quot; &quot;10&quot; ## [2,] &quot;Alberto&quot; &quot;2030&quot; ## [3,] &quot;Juan&quot; &quot;Francisco&quot; ¿Qué pasó?, al no tener los datos completos, al querer crear una matriz de dos columnas por el tamaño del vector (en este caso, el más largo) no coinciden los datos ingresados (5 datos) con el “espacio disponible” en la matriz (6 datos), por lo que, el primer valor se repite para llenar el vació. La solución consiste en agregar la coma que nos hizo falta en el primer vector e intentar de nuevo. Otro problema puede ser que, supongamos que tenemos un vector en secuencia del 1 hasta el 31 y queremos representar solo el mes de mayo del 2017 vector &lt;- 1:31 matrix(vector, nrow = 5, ncol=7, byrow=T) ## Warning in matrix(vector, nrow = 5, ncol = 7, byrow = T): la longitud de ## los datos [31] no es un submúltiplo o múltiplo del número de filas [5] en ## la matriz ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] ## [1,] 1 2 3 4 5 6 7 ## [2,] 8 9 10 11 12 13 14 ## [3,] 15 16 17 18 19 20 21 ## [4,] 22 23 24 25 26 27 28 ## [5,] 29 30 31 1 2 3 4 Vemos que R nos ha devuelto un error que nos indica que el vector de datos no es un submúltiplo o múltiplo del número de filas y columnas de la matriz, en otras palabras, la matriz es de 5 renglones por 7 columnas, es decir, tendrá un espacio para ingresar 35 valores y nosotros estamos ingresando solo 31, por lo que R intentará completar la matriz repitiendo el vector hasta completar los 35 valores. Si nosotros no queremos que suceda esto debemos de completar la cantidad de datos, existen varias maneras de solucionar este problema, este es uno de varias de ellas: vector &lt;- 1:31 matrix( c(vector, NA, NA, NA, NA), nrow = 5, ncol = 7, byrow = T ) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] ## [1,] 1 2 3 4 5 6 7 ## [2,] 8 9 10 11 12 13 14 ## [3,] 15 16 17 18 19 20 21 ## [4,] 22 23 24 25 26 27 28 ## [5,] 29 30 31 NA NA NA NA Lo que sucede aquí es que al vector le agregamos 4 valores NA que significa que no están disponibles y ahora tenemos un vector de longitud 35, la cual entra exactamente en la matriz de 5*7. 2.2.3 Data Frame Los dataframes, son una clase parecida a las matrices, sin embargo, poseen determinadas características que las hacen más útiles en ciertas ocasiones. Al igual que los vectores y matrices, existen varias formas de crear data frames, una forma sencilla de crearlos es especificar los datos de las columnas como en el ejemplo siguiente: data.frame( columna1 = 1, columna2 = 1:5, columnay = LETTERS[1:5], z = runif(5) ) ## columna1 columna2 columnay z ## 1 1 1 A 0.71004536 ## 2 1 2 B 0.93508764 ## 3 1 3 C 0.18977092 ## 4 1 4 D 0.01928205 ## 5 1 5 E 0.99139633 2.2.3.1 Crear un Data frame Crear un data frame a partir de varios vectores: vec1 &lt;- c(&quot;Francisco&quot;, &quot;Alberto&quot;, &quot;Enrique&quot;, &quot;Juan&quot;) vec2 &lt;- c(500, 200, 650, 300) datos &lt;- data.frame(Clientes = vec1, Puntos = vec2) datos ## Clientes Puntos ## 1 Francisco 500 ## 2 Alberto 200 ## 3 Enrique 650 ## 4 Juan 300 Crear un data frame a partir de una matriz: Nombre &lt;- c(&quot;Francisco&quot;, &quot;Alberto&quot;, &quot;Enrique&quot;, &quot;Juan&quot;) Puntos &lt;- c(500, 200, 650, 300) m &lt;- matrix(c(Nombre, Puntos), ncol = 2) datos &lt;- as.data.frame(m) datos ## V1 V2 ## 1 Francisco 500 ## 2 Alberto 200 ## 3 Enrique 650 ## 4 Juan 300 2.2.3.2 Trabajar con Data frames Continuaremos trabajando con el siguiente data frame, es necesario recordar que se puede llamar de cualquier forma, en este caso se llamará de manera genérica, df : Nombre &lt;- c(&quot;Francisco&quot;, &quot;Alberto&quot;, &quot;Enrique&quot;, &quot;Juan&quot;, &quot;Francisco&quot;, &quot;Alberto&quot;, &quot;Enrique&quot;, &quot;Juan&quot;) Puntos &lt;- c(500, 200, 650, 300, 300, 350, 600, 400) df &lt;- data.frame(Clientes = Nombre, Puntos = Puntos) df ## Clientes Puntos ## 1 Francisco 500 ## 2 Alberto 200 ## 3 Enrique 650 ## 4 Juan 300 ## 5 Francisco 300 ## 6 Alberto 350 ## 7 Enrique 600 ## 8 Juan 400 Nombrar las columnas del data frame colnames(df) &lt;- c(&quot;Cliente&quot;, &quot;Puntuación&quot;) df ## Cliente Puntuación ## 1 Francisco 500 ## 2 Alberto 200 ## 3 Enrique 650 ## 4 Juan 300 ## 5 Francisco 300 ## 6 Alberto 350 ## 7 Enrique 600 ## 8 Juan 400 Nombrar las filas del data frame rownames(df) &lt;- c(&quot;C1&quot;, &quot;C2&quot;, &quot;C3&quot;, &quot;C4&quot;, &quot;C5&quot;, &quot;C6&quot;, &quot;C7&quot;, &quot;C8&quot;) df ## Cliente Puntuación ## C1 Francisco 500 ## C2 Alberto 200 ## C3 Enrique 650 ## C4 Juan 300 ## C5 Francisco 300 ## C6 Alberto 350 ## C7 Enrique 600 ## C8 Juan 400 Nombrar las columnas y las filas de la matriz dimnames(df) &lt;- list(c(&quot;C-1&quot;, &quot;C-2&quot;, &quot;C-3&quot;, &quot;C-4&quot;, &quot;C-5&quot;, &quot;C-6&quot;, &quot;C-7&quot;, &quot;C-8&quot;),c(&quot;Cliente&quot;, &quot;Puntos&quot;)) df ## Cliente Puntos ## C-1 Francisco 500 ## C-2 Alberto 200 ## C-3 Enrique 650 ## C-4 Juan 300 ## C-5 Francisco 300 ## C-6 Alberto 350 ## C-7 Enrique 600 ## C-8 Juan 400 Obtener los primeros valores de un data frame (tres en este caso): head(df,3) ## Cliente Puntos ## C-1 Francisco 500 ## C-2 Alberto 200 ## C-3 Enrique 650 Obtener los últimos valores de una matriz (tres en este caso): tail(df,3) ## Cliente Puntos ## C-6 Alberto 350 ## C-7 Enrique 600 ## C-8 Juan 400 Obtener los nombres de los clientes: df$Cliente ## [1] Francisco Alberto Enrique Juan Francisco Alberto Enrique ## [8] Juan ## Levels: Alberto Enrique Francisco Juan Una alternativa poco recomendada df[,1] ## [1] Francisco Alberto Enrique Juan Francisco Alberto Enrique ## [8] Juan ## Levels: Alberto Enrique Francisco Juan Obtener los nombres ordenados: sort(df$Cliente) ## [1] Alberto Alberto Enrique Enrique Francisco Francisco Juan ## [8] Juan ## Levels: Alberto Enrique Francisco Juan Obtener los nombres de los clientes sin repetir: unique(df$Cliente) ## [1] Francisco Alberto Enrique Juan ## Levels: Alberto Enrique Francisco Juan Obtener los nombres de los clientes sin repetir y ordenados: sort(unique(df$Cliente)) ## [1] Alberto Enrique Francisco Juan ## Levels: Alberto Enrique Francisco Juan Obtener el dataframe ordenado según la cantidad de Puntos (ascendente): df[order(df$Puntos), ] ## Cliente Puntos ## C-2 Alberto 200 ## C-4 Juan 300 ## C-5 Francisco 300 ## C-6 Alberto 350 ## C-8 Juan 400 ## C-1 Francisco 500 ## C-7 Enrique 600 ## C-3 Enrique 650 Obtener el dataframe ordenado según la cantidad de Puntos (descendente): df[order(df$Puntos, decreasing = TRUE), ] ## Cliente Puntos ## C-3 Enrique 650 ## C-7 Enrique 600 ## C-1 Francisco 500 ## C-8 Juan 400 ## C-6 Alberto 350 ## C-4 Juan 300 ## C-5 Francisco 300 ## C-2 Alberto 200 Note que el data frame NO queda ordena debido a que los datos están saliendo a consola, si buscamos que se queden ordenados, tendríamos que asignarlos a la variable misma o en su defecto a una nueva variable, por ejemplo, df &lt;- df[order(df$Puntos, decreasing = TRUE), ]. Obtener al primer cliente y sus puntos: df[1,] ## Cliente Puntos ## C-1 Francisco 500 Obtener la suma de los puntos: sum(df$Puntos) ## [1] 3300 2.2.4 Lista Hasta ahora hemos visto vectores, matrices y data frames para organizar la información dentro del entorno de R. Existe otro tipo de clase que también será de utilidad, en R la clase list (lista) y es parecido a un vector, sin embargo, dentro de ella puede contener varios objetos, donde cada objeto puede ser de un tipo diferente. Debido a la flexibilidad de las listas, su estructura permite crear e integrar objetos de esta clase con suma facilidad, así que no es raro encontrar listas dentro de otras listas. 2.2.4.1 Crear una lista Observe que para crear una lista, es necesario usar la función list(...), donde cada parámetro que se ingrese será parte de un índice. Recordando la forma de ver de un vector, era como la fila del banco, una lista es como tren, donde en cada vagón tiene una cantidad finita \\(n\\) de objetos de la misma clase, en el primer vagón puede estar \\(x\\) materia prima sin procesar, en el segundó vagón puede estar algo similar o algún otro tipo de cargamento y así sucesivamente. lista &lt;- list(1:10, c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) lista ## [[1]] ## [1] 1 2 3 4 5 6 7 8 9 10 ## ## [[2]] ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; En este caso, para saber lo que contiene cada vagón, usaremos el doble corchete [[i]] donde i representa un número de los “vagones” de la lista. lista[[1]] ## [1] 1 2 3 4 5 6 7 8 9 10 lista[[2]] ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; También es posible crear listas nombradas, es decir para facilitar el acceso e interacción, las listas pueden tener nombres para sus objetos (O sus “vagones”&quot; haciendo referencia a la explicación pasada). Tren &lt;- list(vagon1 = 1:10, vagon2 = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)) Ahora el acceso a la lista nombrada “Tren”, se vuelve más sencilla Tren$vagon1 ## [1] 1 2 3 4 5 6 7 8 9 10 Tren$vagon2 ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; 2.2.4.2 Trabajar con listas Para conocer la cantidad de elementos (vagones) en la lista: length(lista) ## [1] 2 El caso es el mismo para una lista nombrada: length(Tren) ## [1] 2 Para conocer la cantidad de objetos dentro de un elemento (vagón) en la lista: length(lista[[1]]) ## [1] 10 Y para la lista nombrada se puede acceder la misma manera que en una lista no nombrada o a través de su nombre: length(Tren[[1]]) ## [1] 10 length(Tren$vagon1) ## [1] 10 Acceder a un elemento específico dentro de un índice de la lista: lista[[1]][5] ## [1] 5 O lo que es equivalente en una lista nombrada: Tren$vagon1[5] ## [1] 5 Añadir más elementos a la lista: lista[[3]] &lt;- c(10, 20, 30, 40, 50) lista ## [[1]] ## [1] 1 2 3 4 5 6 7 8 9 10 ## ## [[2]] ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; ## ## [[3]] ## [1] 10 20 30 40 50 O en una lista nombrada Tren$vagon3 &lt;- c(10, 20, 30, 40, 50) Tren ## $vagon1 ## [1] 1 2 3 4 5 6 7 8 9 10 ## ## $vagon2 ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; ## ## $vagon3 ## [1] 10 20 30 40 50 Modificar un nombre (o agregar un nombre en caso de que no tenga): names(lista)[1] &lt;- &quot;vagon1&quot; lista ## $vagon1 ## [1] 1 2 3 4 5 6 7 8 9 10 ## ## $&lt;NA&gt; ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; ## ## $&lt;NA&gt; ## [1] 10 20 30 40 50 Modificar todos los nombres (o agregarle nombres en caso de que no tenga): names(lista) &lt;- c(&quot;vagon1&quot;, &quot;vagon2&quot;, &quot;vagon3&quot;) lista ## $vagon1 ## [1] 1 2 3 4 5 6 7 8 9 10 ## ## $vagon2 ## [1] &quot;A&quot; &quot;B&quot; &quot;C&quot; ## ## $vagon3 ## [1] 10 20 30 40 50 2.3 Manejo de datos 2.3.1 Salvar datos En algún momento, tendremos la necesidad de guardar o leer algo en un formato determinado, sea .csv o .Rdata, veamos unos ejemplos que podrán ser de utilidad. 2.3.1.1 CSV (Comma-separated values) Un formato muy utilizado en R aparte de los .RData (que son archivos especiales de R), para exportar los datos en dicho formato: df = data.frame(runif(10), runif(10), runif(10)) names(df) = c(&quot;dato1&quot;, &quot;dato2&quot;, &quot;dato3&quot;) write.table(df, file = &quot;dataframe1.csv&quot;, sep = &quot;,&quot;, col.names = NA, qmethod = &quot;double&quot;) En caso de que no se quisiera exportar el nombre de las filas, basta con modificar un poco el código, como en el siguiente ejemplo: write.table(df, file = &quot;dataframe2.csv&quot;, sep = &quot;,&quot;, row.names = FALSE, qmethod = &quot;double&quot;) 2.3.1.2 .RData Si tienes objetos que te gustaría guardar como tal para luego procesarlos o simplemente se te hace más sencillo comprenderlo sobre un .csv, los comandos serán los siguientes: foo = &quot;bar&quot; save(foo, file=&quot;nombre.RData&quot;) 2.3.2 Leer datos 2.3.2.1 CSV read.table(&quot;dataframe1.csv&quot;, header = TRUE, sep = &quot;,&quot;, row.names = 1) Y si no se quieren importar los nombres de las filas optaremos por el siguiente comando: read.table(&quot;dataframe2.csv&quot;, header = TRUE, sep = &quot;,&quot;) Aunque, la forma más sencilla de importar un .csv es a través del comando read.csv(...), cuya implementación es la siguiente: read.csv(file, header = TRUE, sep = &quot;,&quot;, dec = &quot;.&quot;, ...) Dónde: Argumentos Significado o uso file Ruta al archivo, en caso de estar en el mismo directorio de trabajo poner solo el nombre del archivo, de otro modo ingresar la ruta completa header Valor lógico para determinar si el archivo incluye encabezados en la primera línea. sep Este campo sirve para especificar el carácter de separación. dec El carácter usado para los puntos decimales ... Ver la documentación para argumentos extras Un ejemplo seria el siguiente: csv &lt;- read.csv(&quot;dataframe1.csv&quot;) 2.3.2.2 .RData Para volver a cargar los datos: load(&quot;nombre.RData&quot;) Para llamar el objeto, basta con volver a introducir su variable, que, aunque no haya sido creada antes de usar la función load(), esta se encarga de crear el objeto y asignarle el valor que decidimos guardar en un principio, ver 2.3.1.2. foo ## [1] &quot;bar&quot; 2.3.2.2.1 Problemas comunes 2.3.2.2.1.1 Error al cargar los datos R marca un error sobre los datos se tratan de cargar no existen pero yo veo que sí existen en mi carpeta. Lo más probable es que el directorio de trabajo de R no sea el mismo que donde están los datos, la función getwd() sirve para revisar cuál es el directorio de trabajo actual, será necesario revisar nuevamente los primeros pasos de esté capitulo para corregir el problema con el directorio de trabajo. 2.3.2.2.1.2 ¿Dónde están los datos? Cuando se utilizan las funciones read.table(...) o load(...) utilizan la ruta del directorio de trabajo actual para guardar los datos, es decir, que si esa ruta apunta a tus documentos, los datos se guardaran en esa carpeta, será necesario revisar nuevamente los primeros pasos de esté capitulo para ver cómo funciona el directorio de trabajo. 2.3.2.2.1.3 ¿Cuáles son los datos que cargué con .RData? Si por algún motivo se desconoce cuáles son los datos que se están cargando (No vienen documentados de alguna manera, etc.), la función load(...) incluye el parámetro verbose que por default el FALSE, pero si cambiamos dicho parámetro a TRUE, nos dirá que el nombre del objeto que estamos cargando al entorno de R, así podremos llamarlo y ver qué es lo que contiene. load(&quot;nombre.RData&quot;, verbose = TRUE) ## Loading objects: ## foo foo ## [1] &quot;bar&quot; 2.4 Tratamiento de datos Es momento de empezar a trabajar los datos para poder obtener más información sobre ellos, R incluye funciones bastante útiles, los cuales se pueden encontrar al final de documento, por el momento, conoceremos más sobre la función apply. 2.4.1 Función Apply La función apply(...) permite realizar un cálculo (como el promedio) por fila ó por columna (sin importar si es una matriz o un dataframe), el resultado de dicha operación será un vector de longitud \\(p\\) con el resultado de la operación realizada, ya sea por filas o por columnas. Su implementación es la siguiente: apply(X, MARGIN, FUN) Donde apply() corresponde al nombre de la función y todo lo que está dentro de los paréntesis son los argumentos de dicha función. Argumentos Significado X Es el vector o matriz original MARGIN Indica donde se aplicara la función (1 indica fila, 2 indica columna) FUN Es la función a aplicar (Suma, promedio, entre muchas otras) Para ver un ejemplo, crearemos una matriz con 9 valores y sacaremos el promedio por columna. x &lt;- matrix(data = 1:9, nrow=3, ncol=3, byrow = TRUE) x ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 ## [3,] 7 8 9 apply(x,2,mean) ## [1] 4 5 6 El argumento 2 en apply(x,2,mean) indica que el cálculo del promedio debe realizarse en la segunda dimensión, es decir, en las columnas. 2.4.2 Libreria dplyr Dicha librería no se encuentra instalada por defecto en R para instalarla, como se vio en los primeros pasos de este capítulo, se usará el comando: install.packages(&quot;dplyr&quot;) Para aprender a usar esta librería usaremos el comando: Y utilizaremos los siguientes datos: v1 &lt;- c(&quot;Perro&quot;, &quot;Gato&quot;, &quot;Lagarto&quot;, &quot;Orca&quot;, &quot;Águila&quot;, &quot;Jirafa&quot;) v2 &lt;- c(&quot;Mamífero&quot;, &quot;Mamífero&quot;, &quot;Reptil&quot;, &quot;Mamífero&quot;, &quot;Ave&quot;, &quot;Mamífero&quot;) v3 &lt;- c(&quot;Carnívoro&quot;, &quot;Carnívoro&quot;, &quot;Carnívoro&quot;, &quot;Carnívoro&quot;, &quot;Carnívoro&quot;, &quot;Herbívoro&quot;) v4 &lt;- c(20,15,25,29,20,25) Animales &lt;- data.frame(Nombre = v1, Especie = v2, Alimentacion = v3, Tiempo_Vida = v4) Los datos se detallan a continuación: Nombre Especie Alimentacion Tiempo_Vida Perro Mamífero Carnívoro 20 Gato Mamífero Carnívoro 15 Lagarto Reptil Carnívoro 25 Orca Mamífero Carnívoro 29 Águila Ave Carnívoro 20 Jirafa Mamífero Herbívoro 25 2.4.3 Filtrar datos filter() permite seleccionar una serie de filas en un data frame, el primer argumento es el nombre del data frame (en este caso Animales), el segundo y resto de los argumentos son las expresiones a filtrar en el data frame: Por ejemplo, filtraremos por los animales mamíferos: Mamiferos &lt;- filter(Animales, Especie == &quot;Mamífero&quot;) Mamiferos Nombre Especie Alimentacion Tiempo_Vida Perro Mamífero Carnívoro 20 Gato Mamífero Carnívoro 15 Orca Mamífero Carnívoro 29 Jirafa Mamífero Herbívoro 25 Ahora filtraremos por los animales mamíferos y reptiles que sean carnívoros y tengan un tiempo de vida mayor a 19 años: filtrados &lt;- filter(Animales, Especie == &quot;Mamífero&quot; | Especie == &quot;Reptil&quot;, Alimentacion == &quot;Carnívoro&quot;, Tiempo_Vida &gt; 19) filtrados Nombre Especie Alimentacion Tiempo_Vida Perro Mamífero Carnívoro 20 Lagarto Reptil Carnívoro 25 Orca Mamífero Carnívoro 29 Para seleccionar datos por su posición dplyr provee la función slice(...) Por ejemplo, seleccionaremos los primeros dos animales. seleccionados &lt;- slice(Animales, 1:2) seleccionados Nombre Especie Alimentacion Tiempo_Vida Perro Mamífero Carnívoro 20 Gato Mamífero Carnívoro 15 2.4.4 Ordenar datos La función arrange(...) funciona de manera similar a filter(...) solo que, en vez de filtrar los datos, los ordena. Por ejemplo, ordenaremos los animales por su especie y luego por su tiempo de vida ordenados &lt;- arrange(Animales, Especie, Tiempo_Vida) ordenados Nombre Especie Alimentacion Tiempo_Vida Águila Ave Carnívoro 20 Gato Mamífero Carnívoro 15 Perro Mamífero Carnívoro 20 Jirafa Mamífero Herbívoro 25 Orca Mamífero Carnívoro 29 Lagarto Reptil Carnívoro 25 Para ordenarlos de manera descendente usaremos la función desc(...) ordenados &lt;- arrange(Animales, Especie, desc(Tiempo_Vida)) ordenados Nombre Especie Alimentacion Tiempo_Vida Águila Ave Carnívoro 20 Orca Mamífero Carnívoro 29 Jirafa Mamífero Herbívoro 25 Perro Mamífero Carnívoro 20 Gato Mamífero Carnívoro 15 Lagarto Reptil Carnívoro 25 2.4.5 Seleccionar columnas específicas De manera seguida tendremos que trabajar con grandes cantidades de datos con varias columnas, pero en el momento, solo algunas podrán ser de tu interés la función select(...) permite un rápido trabajo para seleccionar dichas columnas, por ejemplo, queremos conocer el tiempo de vida de cada animal, entonces: Tiempo_vida_por_Animal &lt;- select(Animales, Nombre, Tiempo_Vida) Tiempo_vida_por_Animal Nombre Tiempo_Vida Perro 20 Gato 15 Lagarto 25 Orca 29 Águila 20 Jirafa 25 2.4.6 Renombrar una columna Para renombrar una columna, la librería dplyr provee también una útil función llamada rename(...), con ella cambiaremos el nombre de la columna Nombre del data frame Animales por Animal: Animales &lt;- rename(Animales, Animal = Nombre) Animales Animal Especie Alimentacion Tiempo_Vida Perro Mamífero Carnívoro 20 Gato Mamífero Carnívoro 15 Lagarto Reptil Carnívoro 25 Orca Mamífero Carnívoro 29 Águila Ave Carnívoro 20 Jirafa Mamífero Herbívoro 25 2.4.7 Extraer los valores únicos Otra útil función dentro de esta librería es la función distinct(...) que encuentra los valores distintos en una tabla, por ejemplo las Especies de los animales: Especies &lt;- distinct(Animales, Especie) Especies ## Especie ## 1 Mamífero ## 2 Reptil ## 3 Ave O también las especies y alimentación Especie_Alimentacion &lt;- distinct(Animales, Especie, Alimentacion) Especie_Alimentacion Especie Alimentacion Mamífero Carnívoro Reptil Carnívoro Ave Carnívoro Mamífero Herbívoro 2.4.8 Agregar nuevas columnas Es posible modificar las columnas existentes o agregar nuevas columnas con la función mutate(...) de la librería dplyr, por ejemplo, agregaremos dos años al tiempo de vida de los animales y añadiremos también otra columna con datos NA. Animales2 &lt;- mutate(Animales, Tiempo_Vida = Tiempo_Vida + 2, Otra_Columna = NA) Animales2 Animal Especie Alimentacion Tiempo_Vida Otra_Columna Perro Mamífero Carnívoro 22 NA Gato Mamífero Carnívoro 17 NA Lagarto Reptil Carnívoro 27 NA Orca Mamífero Carnívoro 31 NA Águila Ave Carnívoro 22 NA Jirafa Mamífero Herbívoro 27 NA 2.4.9 Procesar datos La función summarise(...). Colapsa un data frame en una fila, por ejemplo el tiempo de vida en promedio de los animales. Vida_Promedio &lt;- summarise(Animales, Tiempo_Vida = mean(Tiempo_Vida, na.rm = TRUE)) Vida_Promedio ## Tiempo_Vida ## 1 22.33333 2.4.9.1 Datos agrupados group_by(...) aunque no modifica los datos, sirve para trabajar en conjunto con la función summarise(...), por ejemplo, el tiempo de vida promedio entre las especies. Agrupados &lt;- group_by(Animales, Especie) Especie_Vida_Promedio &lt;- summarise(Agrupados, Tiempo_Vida = mean(Tiempo_Vida, na.rm = TRUE)) Especie_Vida_Promedio Especie Tiempo_Vida Ave 20.00 Mamífero 22.25 Reptil 25.00 O el tiempo de vida en promedio por Especie y su alimentación: Agrupados &lt;- group_by(Animales, Especie, Alimentacion) EspecieAlimentacion_Vida_Promedio &lt;- summarise(Agrupados, Tiempo_Vida = mean(Tiempo_Vida, na.rm = TRUE)) EspecieAlimentacion_Vida_Promedio Especie Alimentacion Tiempo_Vida Ave Carnívoro 20.00000 Mamífero Carnívoro 21.33333 Mamífero Herbívoro 25.00000 Reptil Carnívoro 25.00000 "],
["RStudio.html", "Capítulo 3 Introducción a RStudio 3.1 El entorno y los paneles 3.2 Proyectos", " Capítulo 3 Introducción a RStudio 3.1 El entorno y los paneles RStudio es un entorno de desarrollo para el lenguaje de programación en R de código libre, contiene potentes herramientas para facilitar el desarrollo de procesos matemáticos, estadísticos, llevar un control de versiones, fácil visualización, modificación e implementación de las rutinas en R, además entre sus potentes herramientas incluye Rmarkdown, el cual fue desarrollado para crear documentos interactivos, para facilitar la transmisión de ideas entre los desarrolladores de R sin tener que preocuparse por tener que desarrollar la documentación con diversos programas, pero por el momento nos enfocaremos solo en conocer el entorno de desarrollo de RStudio. En la siguiente imagen se puede observar la interfaz completa para RStudio. Rstudio Rstudio se compone por 4 secciones, las cuales están divididas en 12 importantes paneles que pueden ser configurados a las necesidades de cada persona. 3.1.1 Panel de código Panel de código El panel de código es básicamente imprescindible, nos permitirá estar trabajando con todos nuestros scripts, ejecutarlos, en este panel además de permitirnos escribir nuestro código para salvarlo y después utilizarlo, cuenta con resaltado de sintaxis para los scripts de R, para que en el aspecto visual podamos ir identificando posibles errores al momento; para modificar el resaltado de sintaxis, tamaño de letra y otros aspectos de este panel solo es necesario presionar [ALT] + [T] o presionar en la barra de herramientas seleccionar Tools y presionar [ALT] + [G] o directamente en Global Options..., seleccionamos Appearance y nos saldrá la siguiente ventana: Appearance En esta ventana podremos controlar el resaltado de sintaxis para hacerlo lo más visualmente atractivo para nosotros, así como el tamaño y la fuente que deseamos utilizar, Para aplicar los cambios una vez que nos encontremos satisfechos solo se ha de presionar el botón [OK], si queremos descartar todos los cambios que se realizaron en ese momento (si no se ha presionado [Apply] u [OK]), se ha de presionar el botón [Cancel] y para ir observando los cambios al momento se ha de presionar el botón [Apply]. Opciones Identificador Uso o significado 1 Pestaña de trabajo actual. 2 Abrir el código en una ventana independiente. 3 Guardar el archivo del código actual. 4 Si esta seleccionado, el código será ejecutado cada vez que se guarde el archivo. 5 Buscar o Reemplazar una parte del código. 6 Herramientas para el código. 7 Genera un reporte del código actual en base a los comentarios en el código (No recomendable). 8 Ejecutar la línea de código seleccionada. 9 Se vuelve a ejecutar el bloque ejecutado anteriormente. 10 Ejecutar todo el código con el comando source(...). 11 Despliega una ventana para ayudar en la navegación del código (Ideal para navegar entre grandes scripts). Además de tener todas estás funcionalidades a la mano, también es posible acceder a algunas de ellas de manera rápida a través del teclado como se puede observar en la siguiente tabla. Comando Uso [Control] + [Shift] + [A] Formatea el código de R que se encuentre seleccionado. [Tab] Abre la opción de auto-completado en función a lo que se va escribiendo. [Control] + [Enter] Ejecutar la línea que se encuentre seleccionada (pueden ser varias). [Control] + [S] Salvar el archivo en el que se está trabajando. [F1] Acceder a la ayuda del comando que se está escribiendo o esté seleccionado. 3.1.2 Panel de Consola Consola Este panel es la consola bien conocida de R, donde podremos interactuar directamente con ella o a través del panel de código. Existe un comando que nos servirá de ayuda en caso de que ocupemos abortar la ejecución actual de R [CONTROL] + [C]. Además de que al igual que el Panel de código, el panel de consola cuenta con auto-completado, podemos ir escribiendo un comando y con la tecla [TAB] podemos acceder al auto-completado y en caso de tener dudas podemos usar la tecla [F1] para acceder de manera rápida a la ayuda. 3.1.3 Panel de entorno Dentro los paneles del lado derecho, podemos observar el panel de entorno, el trabajo de este panel es mostrar los datos que nosotros estamos trabajando en R para no perder de vista si ya hemos creado una variable o si dicha variable contiene los datos que debe contener, para poder sacar el máximo provecho a este panel deberemos de considerar lo siguiente: Nos muestra nuestras variables. Permite limpiar la entorno con un solo clic (en vez de escribir el comando rm(list=ls()), RStudio lo hace por nosotros). Permite importar bases de datos en distintos formatos (La primera vez requerirá instalar algunos paquetes). Panel de entorno De manera superficial, este panel en la mayoría de los casos nos puede servir para dar una vista rápida al entorno y saber si la o las variables que creamos ya existen o si nos falta ejecutar alguna parte de nuestro código, ahora veremos más a detalle las opciones que nos ofrece este panel. Opciones de Entorno Identificador Uso o significado 1 Cargar un área de trabajo. 2 Guardar el área de trabajo actual. 3 Importar una nueva base de datos (desde SPSS, CSV, Excel y otros). 4 Limpiar el área de trabajo actual (Entorno). 5 Alternar la vista de los datos entre modo lista y modo tabla. 6 Mostrar los datos creados por varios entornos (Entorno global o a nivel de paquetes). 7 Permite filtrar y buscar algún objeto de interés por su nombre. 8 Así se muestra un vector. 9 Así se muestra una matriz y un dataframe, la diferencia se encuentra en que al crear un dataframe aparece un botón para desplegar sus datos. 10 Muestra los datos que contiene una matriz o un dataframe específico. 3.1.4 Panel de historial Panel de historial El panel del historial es otro panel bastante simple, su importancia radica en que cada vez que un comando es ejecutado irá a parar a este panel, así que sin importar cuantas veces cerremos RStudio, ese historial seguirá ahí, si en algún momento queremos volver a buscar un comando podremos encontrarlo aquí, para conocer más a detalle este panel tenemos las siguientes opciones: Opciones Historial Identificador Uso o significado 1 Cargar un historial. 2 Guardar el historial en un archivo. 3 Mandar al panel de consola el comando seleccionado. 4 Mandar al panel de código el comando seleccionado. 5 Remover los comandos seleccionados del historial. 6 Eliminar todo el historial de comandos usados. 7 Permite filtrar y buscar algún comando de interés por parte de su contenido. 3.1.5 Panel de Construcción Panel de construcción Posiblemente el panel menos utilizado, solo aparece cuando estamos construyendo un paquete para R y su trabajo es construirlo para poder realizar pruebas en el entorno de R, de manera muy superficial tenemos las siguientes opciones: Opciones Construcción Identificador Uso o significado 1 Construir o recargar el paquete. 2 Revisar que el paquete este correctamente instalado (entre otras pequeñas funciones). 3 Diversas opciones que permiten hacer pruebas, empaquetar los paquetes para distribución entre otras funciones. 3.1.6 Panel de Control de versiones (Git) Un panel bastante importante para los que ocupan trabajar con varias versiones de un mismo archivo o los que trabajan en el desarrollo de paquetes para R, hablar del control de versiones y cómo implementarlo en GitHub es agregar otro curso dentro de este curso, por lo que no nos saldremos del alcance y rescataremos las partes más importantes para aquellos que ya saben utilizar el controlador de versiones git. git La imagen anterior es una muestra de del uso de este panel y las opciones que se muestran se describen a continuación Opciones Git Identificador Uso o significado 1 Muestra las diferencias entre la antigua versión de un archivo y su nueva versión. 2 Comenta los archivos seleccionados (staged) para guardar una nueva versión de ellos. 3 Recupera las últimas modificaciones del repositorio realizadas en otras computadoras. 4 Sube al repositorio las últimas modificaciones “comentadas (ver identificador 2)” en la máquina. 5 Muestra un historial de las modificaciones realizadas. 6 Otras opciones (Ignorar un archivo seleccionado o revertir la modificación) 7 Rama (branch) a la que se desea subir las modificaciones del archivo. 8 Recargar el panel. 9 Caja para seleccionar los archivos a comentar (ver identificador 2), ignorar o revertir (ver identificador 7) 10 El estado en el cuál se encuentra el archivo, (M es Modificado, ? es que aún no se encuentra en el repositorio, A significa que se agregará al repositorio y D es que se elimina del repositorio. 11 Es el archivo que está siendo supervisado por el controlador de versiones. 3.1.7 Panel de archivos Volviendo a los paneles sencillos, este panel hace la función de explorador de archivos, para evitar la necesidad de estar abriendo y cerrando esta aplicación, podremos navegar hasta la carpeta de nuestro archivo de interés o si estamos trabajando por proyectos, veremos que esta ventana se actualiza directamente a la carpeta donde está ‘hospedada’ el proyecto, sin duda es de mayor utilidad de esta forma, pero antes de hablar sobre los proyectos en RStudio, veremos un par de paneles más. Panel de archivos La imagen anterior es la vista que comúnmente se obtiene donde las carpetas que todos conocemos (Descargas, Documentos, Escritorio, etc.) son las que nos muestra RStudio, algunas de las opciones más importantes son las siguientes: Opciones Archivos Identificador Uso o significado 1 Crear una nueva carpeta en el directorio de trabajo actual. 2 Seleccionar algún archivo o carpeta para realizar alguna de las operaciones de los identificadores siguientes. 3 Eliminar el archivo o carpeta seleccionado. 4 Renombrar el archivo o carpeta seleccionado. 5 Opciones varias, Copiar o Mover el archivo seleccionado, seleccionar la carpeta actual como directorio de trabajo (reemplaza al comando setwd(...)) , entre otras opciones. 3.1.8 Panel de gráficos La función del panel de gráficos es mostrarnos en este espacio los gráficos que se vayan creando en el entorno de R para una rápida consulta y navegación entre ellos, pero se debe de tener cuidado, si el espacio dejado para este panel es muy pequeño, cuando se intente crear un gráfico, RStudio regresará un error. Las opciones más importantes en el panel son las siguientes: Identificador Uso o significado 1 Ir a la gráfica anterior o siguiente. 2 Realizar Zoom a la gráfica actual. 3 Exportar la gráfica actual. 4 Remover la gráfica actual. 5 Limpiar el entorno de todas las gráficas realizadas. 6 Publicar la gráfica en RPubs. 7 Volver a cargar el panel. 3.1.9 Panel de Paquetes Panel de Paquetes Sin duda un panel que tendrá mucha utilidad, permite conocer de manera rápida los paquetes que tenemos instalados y actualizarlos de ser necesario. Opciones Paquetes Dentro de las opciones de este panel tenemos: Identificador Uso o significado 1 Instalar uno o varios paquetes. 2 Actualizar todos los paquetes que tengan una nueva versión disponible. 3 Buscar un paquete. 4 Actualizar el panel. 3.1.10 Panel de ayuda Panel de ayuda Otro panel sencillo y de gran utilidad, aquí se mostrará la documentación de alguna función, paquete o sobre Rstudio, se puede acceder a él de manera sencilla al estar en el panel de código y tener seleccionada la función o paquete y presionar la tecla [F1], dentro de las características de este panel tenemos Opciones Ayuda Identificador Uso o significado 1 Navegar entre las paginas consultadas. 2 Ir a la página inicial de ayuda. 3 Imprimir la hoja de ayuda actual. 4 Mostrar el panel en una ventana separada (por si no nos ajusta el tamaño de la ventana). 5 Buscar ayuda con un paquete o función especifico. 3.1.11 Panel de visualización La función de este panel es mostrarnos la versión web cuando estamos trabajando con documentos en RMarkdown. Por ejemplo, este documento está diseñado en RMarkdown, por lo que se muestra en el panel de la siguiente manera: Las opciones de este panel son reducidas pues es como un navegador de internet pero solo para nuestro documento, por lo que las opciones que tiene son las siguientes: Opciones de Visualización Identificador Uso o significado 1 Remover la vista actual. 2 Remover todas las vistas. 3 Abrir la vista actual en nuestro navegador web predeterminado. 3.2 Proyectos Un proyecto en RStudio es una carpeta que el programa reconoce como un espacio de trabajo de R, donde dependiendo de las especificaciones iniciales, se puede mantener las versiones del proyecto, crear un paquete para R, una aplicación web con la librería shiny, entre otras cosas útiles, pero siempre manteniendo el orden de los trabajos ya que además de mantener organizados los códigos, RStudio permite recuperar las pestañas abiertas sin importar si se cambió de proyecto, RStudio fue cerrado o si se apagó el sistema operativo. Para crear un nuevo proyecto, tenemos nuestro entorno de una forma muy parecida a la siguiente Rstudio En la parte superior derecha está el botón para crear un nuevo proyecto Nuevo Proyecto Si accedemos al botón podremos ver las siguientes opciones, [New Project] desplegará una ventana para ayudarnos a escoger entre varias opciones. Menú de opciones Las opciones son las siguientes: Opciones del nuevo proyecto Si lo que buscamos es crear un nuevo proyecto desde cero, entonces seleccionaremos [New Directory], por otro lado, si ya tenemos una carpeta con nuestros archivos de R, se puede escoger la opción [Existing Directory], la cual tomará una carpeta normal y la adecuará a nuestro entorno de Rstudio, si se cuenta con la experiencia de haber trabajado con anterioridad con un programa de control de versiones como git o SVN y alguno de ellos está disponible en la máquina, se podrá utilizar la tercera opción, la cual nos ayudará a mantener aún más organizado nuestro código. Empezaremos creando un proyecto vacío. Nuevo proyecto vacío Tenemos varias opciones, como será un proyecto para trabajar los ejercicios de R usaremos la primera opción. Nuevo Proyecto vacío En la ventana de «Crear un nuevo proyecto» podremos escoger el nombre de nuestra carpeta y donde se creará, además nos da dos opciones para integrar nuestro control de versiones git, una vez creado nuestro nuevo proyecto, obsérvese que, automáticamente se asigna el directorio de trabajo hacia la ruta donde se ha creado nuestro proyecto, eso te confirma en el panel de archivos, que ahora muestra solamente nuestro archivo de proyecto .Rproj el cual, si es eliminado, se pierde el entorno de trabajo en RStudio. Proyecto cargado en RStudio Si en vez de crear un nuevo directorio, queremos usar una ruta ya existente, podemos usar la opción de crear proyecto desde un directorio existente, con lo cual podremos buscar la ruta con el botón [Browse] y convertir esa carpeta a un Proyecto de RStudio. Proyecto con un directorio existente Para poder cambiar entre proyectos, solo basta con seleccionar el proyecto, en este caso, los disponibles en la siguiente imagen solo es “DiplomadoR”, pero en caso de tener varios proyectos se podrá seleccionar entre los existentes, en caso de que no aparezca, podemos usar el botón [Open Project…] el cual nos dejará buscar la carpeta en la cual está el archivo .Rproj, o en caso de que no queramos usar ningún proyecto, para hacer pruebas o alguna otra cosa, basta con cerrar el proyecto abierto con el botón [Close Project]. "],
["RMarkDown.html", "Capítulo 4 Introducción a RMarkdown 4.1 Sintaxis de Markdown 4.2 RMarkdown", " Capítulo 4 Introducción a RMarkdown 4.1 Sintaxis de Markdown Esta es una rápida referencia de cómo usar Markdown, para consultar más información sobre Markdown usar el siguiente enlace Github-flavored Markdown info page. 4.1.1 Encabezados o Títulos # H1 ## H2 ### H3 #### H4 ##### H5 ###### H6 De manera alternativa, Para los encabezados de primer y segundo nivel pueden ser utilizados de la siguiente manera: Alt-H1 ====== Alt-H2 ------ 4.1.2 Texto Para usar texto en itálica (cursiva), es a través de *asteriscos* o _Guion bajo_. Para usar texto en negritas, es a través de **doble asterisco** o __doble guion bajo__. Es posible combinarlos con **Una parte en negritas y __además en cursiva__** Para tachar algo usar ~~Texto no deseado~~. DEMOSTRACIÓN Para usar texto en itálica (cursiva), es a través de asteriscos o Guion bajo. Para usar texto en negritas, es a través de doble asterisco o doble guion bajo. Es posible combinarlos con Una parte en negritas y además en cursiva Para tachar algo usar Texto no deseado. 4.1.3 Listas 1. Primer elemento en la lista. 2. Un elemento más. * Una sub-lista o elemento anidado. 1. No importa la numeración, solo son números. 1. Una sub-lista anidada. 4. Último elemento. Otro tipo de listas: * Las listas no ordenadas pueden usar asteriscos - O el símbolo de menos + O el símbolo de más Primer elemento en la lista. Un elemento más. Una sub-lista o elemento anidado. No importa la numeración, solo son números. Una sub-lista anidada. Último elemento. Otro tipo de listas: Las listas no ordenadas pueden usar asteriscos O el símbolo de menos O el símbolo de más 4.1.4 Enlaces Existen varias formas de crear enlaces: [Enlace a Google](https://www.google.com) [Enlace a Google con título](https://www.google.com &quot;Página de Google&quot;) [Enlace a Google][Texto de referencia al enlace] [También es posible usar números para realizar referencias][1] O dejarlo vacío y usar el enlace como propio texto [texto]. URLs y URLs entre los símbolos `&lt;` y `&gt;` automáticamente serán transformados a enlace. http://www.example.com o &lt;http://www.example.com&gt;. [Texto de referencia al enlace]: https://www.google.com [1]: https://www.google.com [texto]: https://www.google.com DEMOSTRACIÓN: Enlace a Google Enlace a Google con título Enlace a Google También es posible usar números para realizar referencias O dejarlo vacío y usar el enlace como propio texto texto. URLs y URLs entre los símbolos &lt; y &gt; automáticamente serán transformados a enlace. http://www.example.com o http://www.example.com. 4.1.5 Imágenes ![Texto alternativo](./assets/images/escudo_uqroo_negro.png &quot;Logo UQroo&quot;) Reference-style: ![Texto alternativo][logo] [logo]: ./assets/images/logo_full.png &quot;Logo UQroo&quot; DEMOSTRACIÓN: Referencia en la misma línea: Mediante referencia de texto: 4.1.6 Tablas El símbolo de dos puntos : es usado como alineado de columnas | Ejemplo | de una | Tabla | |:---------------|:-------------:|---------------:| | La columna tres| está alineada | a la derecha | | La columna dos | está | centrada | | La columna uno | está alienada | a la izquierda | DEMOSTRACIÓN: Ejemplo de una Tabla La columna tres está alineada a la derecha La columna dos está centrada La columna uno está alienada a la izquierda Es necesario que en cada columna haya por lo menos 3 líneas separando cada celda, donde las barras de los extremos son opcionales (|), además de que no es necesario (Pero es preferible), que la tabla tenga que estar alineada en las columnas como se muestra en el siguiente código, esta se seguirá mostrando igual que una alineada: Ejemplo | de una | Tabla --- | --- | --- Menos | ordenada | que la | tabla | anterior DEMOSTRACIÓN: Ejemplo de una Tabla Menos ordenada que la tabla anterior 4.1.7 Bloques de cita &gt; Los bloques de cita son especialmente útiles para enfatizar. &gt; También para realizar citas de texto. &gt; &gt; Esta línea también pertenece al bloque. Esta línea ya no pertenece al bloque al estar separado por un salto de línea. &gt; Sin embargo, siempre es posible utilizar nuevamente los bloques de citas, aunque sean de una línea. DEMOSTRACIÓN: Los bloques de cita son especialmente útiles para enfatizar. También para realizar citas de texto. Esta línea también pertenece al bloque. Esta línea ya no pertenece al bloque al estar separado por un salto de línea. Sin embargo, siempre es posible utilizar nuevamente los bloques de citas, aunque sean de una línea. 4.1.8 HTML en Markdown Es posible insertar código en HTML dentro de Markdown, esto con el fin de añadir algunas funcionalidades que Markdown carece. Por ejemplo, poner el texto de &lt;span style=&quot;color:#DA0101&quot;&gt;otro color&lt;/span&gt;. Por ejemplo, poner el texto de otro color. 4.1.9 Líneas horizontales Es posible poner líneas horizontales para separar zonas de texto usando alguno de los siguientes códigos: Una línea hecha con tres líneas --- O con tres asteriscos *** o tres guiones bajos ___ DEMOSTRACIÓN: Una línea hecha con tres líneas O con tres asteriscos o tres guiones bajos 4.1.10 Saltos de línea Al igual que LaTeX, Markdown necesita doble salto de línea para poder separar párrafos de texto, así como para poder crear tablas, bloques de código o de citas, etc., en caso de que una parte del escrito no se muestre como lo planeado, se tendrá que incluir un salto de línea para separar los dos contextos, ejemplo: La siguiente tabla no se visualiza: | Tabla | Ejemplo | |:-----:|:-------:| | 1 | 2 | Demostración: La siguiente tabla no se visualiza: | Tabla | Ejemplo | |:—–:|:——-:| | 1 | 2 | Corrección: La siguiente tabla ya se visualiza: | Tabla | Ejemplo | |:-----:|:-------:| | 1 | 2 | Demostración: La siguiente tabla ya se visualiza: Tabla Ejemplo 1 2 4.1.11 Código y Resaltado de Sintaxis Los bloques de código son parte de la sintaxis de Markdown, pero, el resaltado de sintaxis no lo es, sin embargo, muchos programas que trabajan con Markdown para exportarlo a HTML ya lo incluyen, tal es el caso como RStudio con RMarkdown, que nos permitirá crear bloques especiales para lenguajes como R, Python, Sql, Bash, RCpp. Existen otros programas que incluyen otros lenguajes para el resaltado de sintaxis, por el momento veremos más a detalle RMarkdown y su forma de trabajar uniendo Markdown y R. En **Markdown** para resaltar partes de `código` es necesario ponerlo entre `comillas inversas`. DEMOSTRACIÓN: En Markdown para resaltar partes de código es necesario ponerlo entre comillas inversas. Los bloques de código, por otra parte, es necesario ponerlo entre tripes comillas inversas y especificar al lenguaje que pertenece ```r x DEMOSTRACIÓN: x &lt;- matrix(NA, ncol=3, nrow=3) 4.2 RMarkdown RMarkdown es una variación del Markdown que integra la facilidad de su estructura con la potencia y desarrollo de R, dicha variación fue desarrollado para crear documentos interactivos, para facilitar la transmisión de ideas entre los desarrolladores de R sin tener que preocuparse por tener que desarrollar la documentación con diversos programas y tener que actualizar los documentos en cada ocasión que se modifica el código, además RMarkdown permite desde un mismo código crear versiones en .pdf, word y html del mismo. Existen algunas diferencias entre Markdown y RMarkdown, mismas que se van a detallar a continuación. 4.2.1 Ecuaciones matemáticas Si algo le hizo falta a Markdown, fue la integración con las ecuaciones matemáticas, es por ello que fue integrado con Rmarkdown para facilitar la explicación de las ecuaciones matemáticas que van implicadas en el código, la manera de escribir ecuaciones es como en LaTeX, rodeado de un símbolo $ al inicio y final para escribirlo en la misma línea del texto y doble $$ para hacerlo en una nueva línea, ejemplo: $$ x^2 - \\sqrt{25} = 20 $$ Donde $x$ es la incógnita. \\[ x^2 - \\sqrt{25} = 20 \\] Donde \\(x\\) es la incógnita. La escritura de ecuaciones matemáticas como en LaTeX nos permite no solo reducir la cantidad de errores en cuanto a las ecuaciones, si no, también tener una excelente visualización de ellos. 4.2.2 Bloques de código ejecutables Al hablar de Markdown, se habló un poco de los bloques de código, dichos bloques sirven para mostrar el código que de los scripts, en RMarkdown el bloque de código es mejor conocido como trozo (chunk) y no solo cumplen la función de bloque de código como Markdown, además muestran el resultado de ejecutar dichas líneas de código y con ayuda de otros paquetes, se pueden hacer partes más interactivas con el fin de facilitar el entendimiento de lo que se desea transmitir. Una diferencia entre los bloques de código de Markdown y los chunk de RMarkdown es su sintaxis, mientras que en Markdown solo permite especificar el lenguaje, en RMarkdown tenemos una serie de opciones que nos permitirán llevar un mejor control de lo que queremos que se muestre. ```r # Código a ejecutar ``` Donde las opciones representan lo siguiente: Parámetro Uso r (Obligatoria) Lenguaje a ejecutar, opciones disponibles r, sql, bash, Python, Rcpp, Stan. NombreChunk (Opcional) Identificador del chunk. echo (Opcional) Valor booleano, permite mostrar o no el bloque de código (TRUE por default). error (Opcional) Valor booleano, detiene la ejecución del código en caso de error (TRUE por default). eval (Opcional) Valor booleano, permite ejecutar o no el bloque de código (TRUE por default). fig.width (Opcional) Valor numérico, en caso de tener como salida del código una gráfica, permite controlar el ancho del tamaño de la misma. fig.height (Opcional) Valor numérico, en caso de tener como salida del código una gráfica, permite controlar el alto del tamaño de la misma. message (Opcional) Valor booleano, en caso de que las librerías muestren un mensaje de ejecución, permite mostrarlo o no. (TRUE por default). warning (Opcional) Valor booleano, en caso de que el código ejecutado tenga una advertencia, permite mostrarla o no. (TRUE por default). Existen otras opciones disponibles y pueden ser consultadas en la siguiente liga https://yihui.name/knitr/options/ 4.2.3 Nuevo documento en RStudio Para crear un nuevo documento de RMarkdown en RStudio utilizaremos el botón de nuevo archivo y presionaremos RMarkdown. Si es la primera ocasión que se utilizar RMarkdown, RStudio detectará que hacen falta algunos paquetes y pedirá permiso para instalarlos, de otro modo, podremos ingresar el título y autor del archivo. Finalmente nos creará un archivo con el template base de RMarkdown, es recomendable que si es la primera interacción con RMarkdown se analice el template y se compile para ver la relación del template con el documento de salida. Cuando estamos trabajando con un archivo de RMarkdown (la extensión es .Rmd), RStudio nos permite compilar dicho archivo a varias versiones a través del botón [Knit], dichas versiones son las que veremos a continuación: Compilar 4.2.3.1 Compilar RMarkdown a HTML La opción de [Knit to HTML] permite traducir de manera sencilla y rápida el archivo .Rmd a .html, siempre y cuando no tenga errores al ejecutar los comandos de R. El botón Knirt tiene te funciones, compilar Rmarkdown (desde ahora .RMD) a HTML, compilar .RMD a PDF y compilar .RMD a .docx (Word), para HTML solo tienes que presionar el botón o compile HTML, que sale en el menú presionando el triangulo que está justo al lado derecho, para PDF es más complicado, requieres de LaTeX, supondremos que no lo conoces, así que no podrás compilar a PDF y PPT último para Word, solo falta presionar de nuevo el menú y escoger compile to Word 4.2.3.2 Compilar RMarkdown a PDF La opción de [Knit to PDF] permite traducir de manera sencilla y rápida el archivo .Rmd a .pdf, siempre y cuando no tenga errores al ejecutar los comandos de R, sin embargo, es necesario que se tenga instalado un compilador de \\(\\LaTeX\\), ya sea TeXlive o Miktex que son los más recomendados. 4.2.3.3 Compilar RMarkdown a WORD La opción de [Knit to Word] permite traducir de manera sencilla y rápida el archivo .Rmd a .docx, siempre y cuando no tenga errores al ejecutar los comandos de R y estén todos los paquetes dependientes de “Rmarkdown” al día. "],
["apendA.html", "Capítulo 5 Funciones de R 5.1 Tabla símbolos básicos 5.2 Tabla funciones básicas 5.3 Tabla de funciones de distribución", " Capítulo 5 Funciones de R 5.1 Tabla símbolos básicos Aritméticos Lógicos Comparativos + Adición == Igual a &amp; Y Lógico - Substracción != Diferente de ! No Lógico * Multiplicación &lt; Menor que / División &gt; Mayor que is.na(x) ¿Es NA? \\(\\hat{ }\\) Potencia &lt;= Menor o igual a is.null(x) ¿Es Null? %/% División de enteros &gt;= Mayor o igual a is.nan(x) ¿Es NaN? 5.2 Tabla funciones básicas Función Matemáticas Función Estadísticas sqrt(x) Raíz de \\(x\\) mean(x) Media exp(x) Exponencial de \\(x\\) sd(x) Desviación estándar log(x) Logaritmo natural de \\(x\\) var(x) Varianza log10(x) Logaritmo base 10 median(x) Mediana sum(x) Suma de los elementos de \\(x\\) quantiles(x) Quantiles prod(x) Producto de los elementos de \\(x\\) cor(x,y) Correlación sin(x) Seno max(x) Valor máximo cos(x) Coseno min(x) Valor mínimo tan(x) Tangente range(x) Retorna el máximo y mínimo round(x,n) Redondea a \\(n\\) dígitos sort(x) Ordena los elementos de \\(x\\) cumsum(x) Calcula las sumas acumuladas summary Resumen de las variables (\\(x_1, x_1 + x_2, + x_1 +\\ldots+x_n\\)) choose(n,k) Combinatoria de \\(n\\) sobre \\(k\\) 5.3 Tabla de funciones de distribución Distribución Función de densidad distribución acumulada función cuantil Uso de números aleatorios Normal dnorm(…) pnorm(…) qnorm(…) rnorm(…) Uniforme dunif(…) punif(…) qunif(…) runif(…) Student’s t dt(…) pt(…) qt(…) rt(…) Chi-cuadrada dchisq(…) pchisq(…) qchisq(…) rchisq(…) Gamma dgamma(…) pgamma(…) qgamma(…) rgamma(…) Normal Multivariada dmvnorm(…) pmvnorm(…) rmvnorm(…) Student’s t Multivariada dmvt(…) pmvt(…) qmvt(…) rmvt(…) Exponencial dexp(…) pexp(…) qexp(…) rexp(…) Cauchy dcauchy(…) pcauchy(…) qcauchy(…) rcauchy(…) Wishart dwish(…) rwish(…) Nota, algunas de estas distribuciones se encuentran en las librerías de MASS, MCMCpack y mvtnorm. "],
["ejercicios.html", "Capítulo 6 Ejercicios 6.1 Primeros pasos 6.2 Vectores y listas 6.3 Matrices y dataframes", " Capítulo 6 Ejercicios 6.1 Primeros pasos Crear la variable x y asignarle el valor 10. Crear la variable y y asignar el resultado de multiplicar x * 10. Crear la variable edad y asignarle tu edad. Realizar una secuencia de 1 hasta edad (Solo crear salida a consola). Crear la variable sec y asignarle la secuencia de 1hasta edad. Multiplicar la variable sec por 3.1415 (Solo crear salida a consola). 6.2 Vectores y listas 6.2.1 Ejercicio 1 Usando la semilla 10 set.seed(10) Una persona quema calorías durante 100 días según una distribución normal rnomr(...), con un promedio de 1900 calorías y una desviación estándar de 150. Obtener la máxima cantidad de calorías quemadas durante un día. Obtener la mínima cantidad de calorías quemadas durante un día. Utilizar la función summary(...) e interpretar los resultados. 6.3 Matrices y dataframes 6.3.1 Ejercicio 1 El profesor quiere conocer el rendimiento del semestre de sus 5 alumnos de maestría: Alberto Francisco Juan Alejandro Oswaldo Primera parcial 7 9 7.5 10 8.5 Segunda parcial 8.3 7.9 8.2 7.1 8.5 Tercera parcial 8 9.5 7 8.3 8.5 ¿Cuál es el promedio de la calificación del grupo en el semestre?: ¿Cuál es el promedio de la calificación del grupo por parcial?: ¿Cuál es el promedio de la calificación de cada alumno en el semestre?: ¿Quíenes han reprobado la materia? 6.3.2 Ejercicio 2 En una pista de carreras, se observan 3 autos dar 4 vueltas: Civic Mazda Tsuru Vuleta 1 110 km 125 km 95 km Vuleta 2 140 km 130 km 105 km Vuleta 3 135 km 125 km 115 km Vuleta 4 135 km 115 km 120 km ¿A qué velocidad va el primer auto en promedio? ¿A qué velocidad va el segundo auto en promedio? ¿A qué velocidad va el tercer auto en promedio? 6.3.3 Ejercicio 3 Si tenemos el peso de 4 personas durante 3 semanas y queremos ver el promedio del peso por persona, ¿Qué comando deberíamos utilizar? Persona 1 Persona 2 Persona 3 Persona 4 Semana 1 79 59 67.5 60 Semana 2 82.3 57.9 68.2 57.1 Semana 3 80 59.5 67 58.3 "]
]
